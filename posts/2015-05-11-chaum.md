---
title: How Diffie-Hellman key exchange works
---

## Alice ##

This is Alice. She owns a burrito restaurant. 
Alice has just created the most incredible burrito recipe, and wants to send it Bob, her most trusted burrito expert. Alice doesn't want to reveal her recipe to Eve, however, because Eve is looking to take over the booming local burrito market. Unfortunately, Eve also owns all the telecommunications infrastructure, so she's able to read all transmissions between Alice and Bob. 

Alice needs a secure way to send her recipe to Bob. By secure, we mean that even if Eve intercepts _everything_ Alice sends, Eve won't be able to make any sense of that data.

## Perfectly secure ##

A one-time pad (OTP) provides perfect security. It's the only known encryption method that has an information-theoretic guarantee of unbreakability.

To perform OTP encryption, we need a plaintext (the message we want to encrypt), and a random key that's at least as long as the plaintext. We then combine the key with the plaintext using modular addition[^1] to produce a ciphertext, which we send to a recipient. The recipient must have a copy of the key, which they'll use to reverse the encryption and obtain the plaintext.

[^1]: XOR is a special case of modular addition.

We use modular addition in OTP encryption because it produces ciphertexts that have the same randomness as the key used to generate it. We call this property of modular addition _randomness preserving_[^2]. If you produce an \\(n\\)-bit ciphertext with a randomness preserving OTP function, and then give the ciphertext to someone who doesn't know the key, to them, it'll look equally likely to have been generated from _any_ \\(n\\)-bit string. The ciphertext `dazfdooefldgsk` could be encoding `password123456` or `bbbbbbbbbbbbbb` or `strike at dawn` or any other possible permutation of 14 characters, and it's _provably_ impossible to distinguish between these possibilities without knowing the key.

[^2]: An easy way to get an intuition for why modular addition is randomness preserving is to imagine that I've got two numbers between one and ten, \\(n\\) and \\(x\\), where \\(n\\) is a number I've picked, and \\(x\\) is a random number. I then calculate $$n + x \pmod{10} \equiv r$$ and tell you that \\(r \\equiv 2\\). An unfortunate attacker who wants to know \\(n\\) will find that for every possible value of \\(n\\), there's a value \\(x\\) that will give \\(r \\equiv 2\\). If \\(n = 4\\), for instance: $$4 + x \pmod{10} \equiv 2$$ when \\(x = 8\\). If \\(n = 7\\): $$7 + x \pmod{10} \equiv 2$$ when \\(x = 5\\), and so on. Because \\(x\\) is random, we have no reason to suppose that \\(x\\) is any particular integer between one and ten, and thus knowing only \\(r \\equiv 2\\) gives us no information about what \\(n\\) is. We can repeat this entire process for as many numbers as we like, allowing us to "transfer" randomness between two arbitrary strings of identical size. We've built up a cryptographic system from known primitives in a mathematically sound way- something that's a recurring motif in cryptography.

Rolling the dice
----------------

Alice knows OTP encryption offers perfect security, so she sits down with some looseleaf and a pencil and some coins and starts writing down coinflips to make her OTP encryption key. For hours, she flips the coins and marks down ones and zeros, her movements mechanical, thoughts elsewhere, flipping and recording and sharpening until the pencil's so short she can barely grasp it. Alice looks up from her neat stack of digit-filled papers to search for a new pencil, but instead begins to imagine Eve breaking into her house and snatching the OTP key, cackling gleefully and speeding off in a stolen Prius. Eve clutching the key, now, and the intercepted message too, softly incanting \\(1 \\oplus 0 = 1\\) and \\(1 \\oplus 1 = 0\\), stripping away the encryption, bit by bit, until she's summoned the entire recipe.

_This is ridiculous_, Alice thinks, trying to calm her paranoid streak, _Eve wouldn't break into your house._ Alice thinks for a while, and realises that Eve controls all the telecommunications infrastructure. _Why would Eve break into my house when she could just intercept the key when I send it to Bob_, Alice thinks, slightly relieved. 

Wait- _she could just intercept the key when I send it to Bob?_ 

Alice stares, mouth agape, at the pages of random digits she's written down, realising that she has no way of getting her key to Bob. Alice is frantic. Maybe she could encrypt the key before she sends it, but then of course she'd need to send Bob _another_ key to decrypt the first key, and she'd be back to the initial quadrilateral, so to speak.

Alice puts away the coins, carefully stacks up the pages, and begins to think. 

## Perfectly useless #

Despite its perfect security, the classic OTP is exquisitely impractical. A OTP key can never be reused[^3], because key reuse makes ciphertexts vulnerable to standard cryptanalysis, nullifying their pefect security guarantee. This means we need to securely send an \\(n\\)-bit key to securely send an \\(n\\)-bit message. If the key is intercepted, the ciphertext can be trivally decrypted- thus, the security of the OTP is equivalent to the security of the method used to transmit the key! If the transmission method isn't secure, the OTP isn't secure either, and if the method *is* secure, why not just use that method to transmit the plaintext itself? It seems like OTP encryption just passes the cryptocurrency-denominated buck to the key transmission method.

[^3]: This non-reusability of keys is why it's called one-time pad encryption, incidentally.

Fortunately, Diffie-Hellman is a smarter type of key transmission, one that's eager to accept said buck, and allows us to solve the key transmission problem without actually transmitting the key proper.

## Sharing secrets ##

Alice has an idea.

She had been fixated on how she would get her key to Bob, inventing ideas that were growing incrementally more insane. After making herself a cup of tea and calming down a bit, though, she realised that OTP encryption doesn't acutally require Bob to have _her_ key; they just need the _same_ key. It was a small realisation, perhaps, but it formed a handhold on what was previously a perfectly smooth surface.

Alice randomly chooses a private key, which she keeps secret by not telling anyone, and not transmitting it - remember, Eve can read everything that Bob will receive.

So instead of sending her private key to Bob, Alice uses a special function to calculate a _public key_ from her private key, and sends _that_ to Bob. 

Bob does the same, choosing a private key \\(Priv_{B}\\), calculating \\(pubkey(Priv_{B}) = Pub_{B}\\), and sending \\(Pub_{B}\\) to Alice.

Alice and Bob now have each other's public keys. 

They then combine their own private key with their counterpart's public key, using an as-yet-unspecified operation \\(\\odot\\), thusly:

Now, let's unpack this a bit. For the above equations to hold, we need some
mystery operation ☉, such that:

$$Priv_A \odot Pub_B = Pub_A \odot Priv_B$$

Luckily, we have a friend named Yvonne who works over
in the number theory department, and she's provided us some candidates for this
operation. One of them is known as _integer addition[^4]._ We can implement
_integer addition Diffie-Hellman_ like so:

[^4]: Technically, Diffie-Hellman only usefully generalizes to finite cyclic groups, and so integer addition, an infinite cyclic group, won't be very useful. From a pedagogical point of view, however, it's easier to motivate a computationally asymetric commutative operation if we have already attained an intuition for the usefulness of commutative operations to key exchange via insecure channels. 

Alice chooses a random number between 1 and 100 (she comes up with 52), and
uses this as her private key. Bob does the same (he comes up with 33). They
have met beforehand, and decided on an arbitrary integer as their _group
parameter_, 23.

``` haskell
value (Perhaps x _) = x
prob (Perhaps _ p) = p

catMaybes' [] = []
catMaybes' (Perhaps Nothing _ : xs) =
  catMaybes' xs
catMaybes' (Perhaps (Just x) p : xs) =
  Perhaps x p : catMaybes' xs

onlyJust :: FDist (Maybe a) -> FDist a
```

CSS
---

Without any CSS to style and structure the new markup, our footnotes remain visible at the bottom of the page, regardless of browser width. Even worse, the sidenotes fall directly beneath related elements, making them completely ineffective until fixed.


Alice and Bob add the group parameter to their private key to produce one
public key each. They can now exchange their public keys, without ever sharing
their private keys.

Now, let's see if we can fulfill the behaviour required by the ☉ operation.

>Pub<sub>A</sub> = 52 + 23 = 75
>Pub<sub>B</sub> = 33 + 23 = 56

>Priv<sub>A</sub> ☉ Pub<sub>B</sub> = 52 + 56 = 109
>Priv<sub>B</sub> ☉ Pub<sub>A</sub> = 33 + 75 = 109

This is a fantastic result- Alice and Bob have arrived at a shared key,
109, without ever sending the private keys over the wire! If Eve wanted to
decrypt their transmissions, she would need to solve the _addition inverse
problem_, also known as _subtraction_, to recover the private keys, and
thereby calculate the shared seed.

We have an obvious deficiency in our protocol: the _addition inverse
problem_ isn't very difficult. Eve knows the group parameter, 23, so when
she intercepts Alice's public key, she can just calculate Alice's private
key by computing 75 - 23 = 52, and from there, calculate the shared secret.

We could try to make the _addition inverse problem_ more difficult by picking
really large numbers, but then it would take as much effort to encrypt the
message as Eve would take to brute-force the private key from the public key
and group parameter.

Maybe we need another operation, so we return to Yvonne from the number theory
department, and ask really politely if maybe she has another operation in
stock, one where we could easily go from private key to public key, but not so
ridiculously easily go from public key to private key again. Something, I don't
know, _asymmetric_ in some sense?

Yvonne asks us to wait, and begins to play some bizzare single-player version
of Jenga with her precarious piles of papers and books, all furrowed brow and
pointed tongue, until she finally emerges with a paper on _modular exponentiation_.

We sit down to read it, and it's starting to look pretty promising. Modular
exponentiation is easy to perform. Naively, we'd calculate  a^x mod n by
multiplying a by a x times, and then taking the result mod n. As we research
further though, we begin to suspect Yvonne from the Number Theory Department is
also secretly moonlighting as a computer scientist, because there exist a suite
of algorithms for performing modular exponentiation far faster than a naive
implementation.

Let's see if it can work as our operation ☉:

Alice and Bob decide on the following group parameters: g = 2 and p = 1117.

They each pick a random private key. Alice picks 23, and Bob picks 51.

Alice computes her private key: $$2^{23} \pmod{1117} = 1055$$

Bob computes his private key: $$2^{51} \pmod{1117} = 138$$

Now they exchange public keys.
Alice computes 138 ^ 23  mod 1117 = 1013
Bob computes 1055 ^ 51 mod 1117 = 1013

Alice and Bob have easily arrived at the same shared key, without ever sending
their private key over the network. But remember, we don't just want it to be
easy to calculate ☉ - we want its inverse to be "difficult", hopefully far more
difficult, so that we spend far less time to send a message than to crack it.
Eve, our omnipotent wiretapper, knows Alices group parameters, and her public
key. She doesn't know her private key, however, so she has to calculate 2 ^ x
mod 1117 = 1055, also known as the _discrete logarithm_.  And Yvonne from the
Number Theory Department has really pulled through this time, because no one
knows of any efficient algorithm for calculating the inverse of modular
exponentiation- the discrete logarithm. 

Solving it is known as the _discrete logarithm problem_, and it's one of the
outstanding problems in computer science. Many suspect that an efficient
non-quantum algorithm does exist, but until/unless it's discovered, we can
simply pick a key size that would make Eve, armed with all the computing power
in the world, take say, a thousand years to find a key.

At this point, the conceptual framework for Diffie-Hellman is in place, and we
can turn to more pragmatic matters: attacks on Diffie-Hellman. Naively, the
only way to calculate \\(x\\) where \\(a^x\\pmod{n} = m\\) is to calculate 
$$a^1\pmod{n}\\a^2\pmod{n}\\a^3\pmod{n}\\\ldots\\a^x\pmod{n}$$ 
until we hit a match. The worst case of this algorithm is
\\(\\mathcal{O}(n)\\), which means that the time required to brute-force a shared key grows
exponentially with the bitlength of the key.

However, there's a number of algorithms[^5] that allow us to compute the discrete
log of any finite group in about \\(\\mathcal{O}(\\sqrt{n})\\) time, and modular exponentiation, being a finite group, is vulnerable to these attacks. Fortunately, this is a
square-root of an exponential, so an attacker using these algorithms against a
128-bit key would be about as fast as an attacker using the naive brute-force
algorithm against a 64-bit key, which doesn't seem to be too bad of a tradeoff.

[^5]: The giant-step, baby-step algorithm and Pollard's rho algorithm can calculate the discrete log of any finite cyclic group in about \\(\\mathcal{O}(\\sqrt{n})\\) time. They are fairly simple algorithms, and I might write another article analysing them in detail. Unfortunately, the literature surrounding index-calculus algorithms is beyond me at the moment, so I won't be doing anything with them except noting their existence, and taking their relative running times on faith.

However, there are also index-calculus attacks that offer performance even
greater than the aforementioned algorithms, requiring key lengths of 1000-2000
bits in order to slow an attacker armed with this algorithm to the speed of a
naive brute-forcer attacking a 64-bit key. And that's why we see \\(\\mathbb{Z}_p^*\\)
Diffie-Hellman implemented in the wild with key lengths in the 1000-2000 bit
range.

Fortunately, \\(\\mathbb{Z}_p^*\\) is not the only finite cyclic group, and as long as we have a finite cyclic group, we can implement Diffie-Hellman with it. Of course, just being a finite cyclic group is mere table stakes for an aspiring Diffie-Hellman cylic group. The real superstar groups, like elliptic curves, have additional properties that make them exempt from certain attacks that affect other groups. I won't say too much more about elliptic curves, because that would take a whole new post, but understanding the bare mechanics of how they work is fairly straightforward. Basically, we take an elliptic curve defined by: 

$$y^2 = x^3 + ax + b$$

and define an operation over points on this curve to wrangle finite cyclic group behaviour out of it. Of course, if it behaves like a finite cyclic group, it _is_ a finite cylic group, and we can use this group in Diffie-Hellman. The resulting group is resistant to the aforementioned index-calculus attacks, so the only known attacks are the O(sqrt(n)) ones, which means we can select key sizes that are an order of magnitude smaller than the ones we used with discrete log Diffie-Hellman, but still maintain comparable resistance to attack.

